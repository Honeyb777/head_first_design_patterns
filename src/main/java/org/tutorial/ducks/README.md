# Step1 오리 시뮬레이션 게임 SimUduck
1. 표준 객체지향 기법을 사용하여 Duck 슈퍼클래스를 만든다.
   - 꽥꽥 소리를 내는 quack 메소드를 가진다.
   - 헤엄을 치는 swim 메소드를 가진다.
   - 모든 오리의 모양이 다르기 떄문에 display 추상 메소드를 가진다.
2. Duck 슈퍼 클래스를 확장해 서로 다른 종류의 오리를 만든다.\
   (MallardDuck, RedheadDuck)
# Step2 오리 시뮬레이션 게임 차별화하기
1. 오리가 날아야하는 조건이 추가됨.
2. Duck 슈퍼 클래스에 fly 메소드를 추가해서 해결하고자함.
# Step3 경고! 심각한 문제 발생
1. Duck 의 몇몇 서브클래스만 날아야 한다는 사실을 깜빡함.
2. Duck 슈퍼 클래스에 fly 메소드를 추가하면서, 날지 않아야 하는 오리들도 날아다니게됨.
3. RubberDuck 클래스의 경우 quack 메소드와 fly 메소드를 오버라이드 처리\
   (유지보수를 생각하면 그렇게 좋은 방법은 아님)
# Step4 상속을 생각하기
1. 나무로된 오리가 추가됨.
2. quack 메소드와 fly 메소드의 경우 오버라이드 처리 하여 아무 행동도 하지 않게 수정함.
   - 규격이 계속 바뀌거나, 오리가 추가될 때 마다 수정이 필요함.
   - 현재까지 진행한 상속의 형태는 좋은 방법이 아님.
# Step5 인터페이스 설계하기
1. 오리마다 규격이 다른 fly 메소드와 quack 메소드를 인터페이스처리하여 분리함.
   - MallardDuck 서브 클래스와 RedheadDuck 서브 클래스는 Flyable 인터페이스와 Quackable 인터페이스를 구현
   - RubberDuck 서브 클래스는 Quackable 인터페이스를 구현
   - DecoyDuck 서브 클래스는 인터페이스를 구현하지 않음
# Step6 해결 방법 고민하기
1. 인터페이스로 처리하는 경우 코드가 중복됨\
   (fly 메소드의 내용에서 공통된 부분을 변경하기 위해서는 서브클래스 개수 만큼 수정이 필요함)
2. 인터페이스를 통해 개별적으로 구현하는 방법도 좋은 방법이 아님.
# Step7 바뀌는 부분과 그렇지 않은 부분 분리하기
1. fly 메소드와 quack 메소드는 Duck 클래스에 있는 오리 종류에 따라 달라지는 부분
2. fly 메소드와 quack 메소드를 Duck 클래스로부터 분리하려면 fly 메소드와 quack 메소드를 Duck 클래스에서 분리하여 각 행동을 나타낼 클래스 집합을 만들어야함.

=> 이후 처리는 Strategy 패턴에서 처리 